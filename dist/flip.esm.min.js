class Utils{static snakeToCamel(t){return t.replace(/(-\w)/g,t=>t[1].toUpperCase())}static nextFrame(t){requestAnimationFrame(()=>requestAnimationFrame(t))}}class ElementHelper{constructor(t){this.element=t}getStyle(t){return window.getComputedStyle(this.element).getPropertyValue(t)}getStyles(t){return t.map(t=>this.getStyle(this.element,t))}setStyle(t,e){this.element.style[Utils.snakeToCamel(t)]=e}addClass(t){this.element.classList.add(t)}addEventListener(t,e){this.element.addEventListener(t,e)}removeEventListener(t,e){this.element.removeEventListener(t,e)}measure(t){return{rect:this.element.getBoundingClientRect(),opacity:this.getStyle("opacity"),others:this.getStyles(t)}}static getTransition(t,e,s){return t.map(t=>`${t} ${e} ${s}`).join(",")}static getTransform(t,e,s,r){const i=[];return(t||e)&&i.push(`translate(${t}px,${e}px)`),1===s&&1===r||i.push(`scale(${s},${r})`),i.join(" ")}}class Flipper{constructor(t,e,s){this.helper=new ElementHelper(t),this.toClass=e,this.otherPropsToFlip=s?[].concat(s):[]}firstLastInvert(){const t=this.helper.measure(this.otherPropsToFlip);this.helper.addClass(this.toClass);const e=this.helper.measure(this.otherPropsToFlip);this.inverted=this.invert(t,e,this.otherPropsToFlip)}play(t,e){return new Promise(s=>{const r=[];if(this.inverted.hasTransformChanged&&r.push("transform"),this.inverted.hasOpacityChanged&&r.push("opacity"),Flipper.forEachPropThatChanged(this.otherPropsToFlip,this.inverted,t=>r.push(t)),!r.length)return void s();this.helper.setStyle("transition",ElementHelper.getTransition(r,t,e));const i=()=>{this.helper.removeEventListener("transitionend",i),this.helper.setStyle("transition",""),s()};this.helper.addEventListener("transitionend",i),this.inverted.hasTransformChanged&&this.helper.setStyle("transform",""),this.inverted.hasOpacityChanged&&this.helper.setStyle("opacity",""),Flipper.forEachPropThatChanged(this.otherPropsToFlip,this.inverted,t=>this.helper.setStyle(t,""))})}invert(t,e,s){const r={translateX:(t.rect.left+t.rect.right)/((2-(e.rect.left+e.rect.right))/2),translateY:(t.rect.top+t.rect.bottom)/((2-(e.rect.top+e.rect.bottom))/2),scaleX:t.rect.width/e.rect.width,scaleY:t.rect.height/e.rect.height,hasOpacityChanged:t.opacity!==e.opacity,opacity:t.opacity,hasOtherPropsToFlipChanged:t.others.map((t,s)=>t!==e.others[s]),otherPropsToFlip:t.others};return r.transform=ElementHelper.getTransform(r.translateX,r.translateY,r.scaleX,r.scaleY),r.hasTransformChanged=!!r.transform,r.hasTransformChanged&&this.helper.setStyle("transform",r.transform),r.hasOpacityChanged&&this.helper.setStyle("opacity",r.opacity),Flipper.forEachPropThatChanged(s,r,(t,e)=>this.helper.setStyle(t,r.otherPropsToFlip[e])),r}static equals(t,e){return t.helper.element===e.helper.element&&t.toClass===e.toClass}static forEachPropThatChanged(t,e,s){t.forEach((t,r)=>{e.hasOtherPropsToFlipChanged[r]&&s(t,r)})}}class Flip{constructor(){this.reset()}withTransition(t="375ms",e="cubic-bezier(0.4, 0.0, 0.2, 1)"){return this.transitionDuration=t||this.transitionDuration,this.transitionTimingFunction=e||this.transitionTimingFunction,this}withClass(t,e,s=[]){if(!t)throw new Error("elements should be defined");if(!e)throw new Error("toClass should be defined");let r;return this.ongoing&&console.warn("withClass(): transition already ongoing"),[].concat(t).forEach(t=>{r=new Flipper(t,e,s),this.flippers.some(t=>Flipper.equals(t,r))||this.flippers.push(r)}),this}go(){return new Promise(t=>{this.ongoing=!0,this.flippers.forEach(t=>t.firstLastInvert()),Utils.nextFrame(()=>{const e=this.flippers.map(t=>t.play(this.transitionDuration,this.transitionTimingFunction));Promise.all(e).then(()=>{this.ongoing=!1,this.reset(),t()})})})}reset(){return this.ongoing&&console.warn("reset(): transition still ongoing"),this.flippers=[],this.withTransition(),this}}export default Flip;
